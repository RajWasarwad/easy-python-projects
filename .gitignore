# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
.pybuilder/
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
#   For a library or package, you might want to ignore these files since the code is
#   intended to run in multiple environments; otherwise, check them in:
# .python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# poetry
#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control
#poetry.lock

# pdm
#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.
#pdm.lock
#   pdm stores project-wide configurations in .pdm.toml, but it is recommended to not include it
#   in version control.

"""
import serial
import struct
import threading
import time

# Global status for graceful shutdown
PROGRAM_STATUS = True

class Gimbal:
    def __init__(self, port, baud=115200):
        self.port = port
        self.baud = baud
        self.ser = None
        
        # --- Internal State (Latest Status) ---
        self.state = {
            "azimuth": 0.0,
            "elevation": 0.0,
            "actuator": "Unknown",
            "brake": "Unknown",
            "last_update": 0
        }
        
        self.lock = threading.Lock()
        self.write_lock = threading.Lock() # Prevents command collision
        self.thread = threading.Thread(target=self._reader_loop, daemon=True)

    # --- Initialization & Lifecycle ---
    def start(self):
        try:
            self.ser = serial.Serial(self.port, self.baud, timeout=0.1)
            self.ser.reset_input_buffer()
            self.thread.start()
            print(f"[Gimbal] Connection established on {self.port}")
            return True
        except Exception as e:
            print(f"[Gimbal] Initialization Error: {e}")
            return False

    def _calculate_xor(self, data):
        xor = 0
        for byte in data:
            xor ^= byte
        return xor

    # --- Background Reader (Status Monitoring) ---
    def _reader_loop(self):
        global PROGRAM_STATUS
        while PROGRAM_STATUS:
            if not self.ser or not self.ser.is_open: break

            # Sync on Header
            header = self.ser.read(1)
            if not header or header[0] != 0xAA: continue

            # Read Length
            len_byte = self.ser.read(1)
            if not len_byte: continue
            msg_len = len_byte[0]

            # Read Body (Type + Payload + Checksum)
            remaining = self.ser.read(msg_len - 2)
            if len(remaining) < (msg_len - 2): continue

            # Checksum Verification
            full_packet_minus_cs = header + len_byte + remaining[:-1]
            if self._calculate_xor(full_packet_minus_cs) != remaining[-1]:
                continue

            msg_type = remaining[0]
            payload = remaining[1:-1]
            self._parse_incoming(msg_type, payload)

        if self.ser:
            self.ser.close()
            print("[Gimbal] Serial port closed.")

    def _parse_incoming(self, msg_type, payload):
        with self.lock:
            self.state["last_update"] = time.time()
            if msg_type == 0x0A: # Status: Az/El
                self.state["azimuth"], self.state["elevation"] = struct.unpack('<ff', payload)
            elif msg_type in [0x25, 0x29]: # Status: Actuator
                mapping = {0x00: "Retracted", 0xFF: "Extended", 0x55: "In Motion", 0x65: "In Motion"}
                self.state["actuator"] = mapping.get(payload[0], "Unknown")
            elif msg_type == 0x27: # Status: Brake Engaged
                self.state["brake"] = "Engaged"
            elif msg_type == 0x28: # Status: Brake Disengaged
                self.state["brake"] = "Disengaged"

    # --- Command Methods (Sending Data) ---
    def _send_command(self, msg_type, payload_bytes):
        """Internal helper to construct and send packets."""
        header = 0xAA
        # Length = Header(1) + LenByte(1) + Type(1) + Payload(N) + Checksum(1)
        length = 1 + 1 + 1 + len(payload_bytes) + 1
        
        packet = bytearray([header, length, msg_type])
        packet.extend(payload_bytes)
        packet.append(self._calculate_xor(packet))

        with self.write_lock:
            if self.ser and self.ser.is_open:
                self.ser.write(packet)

    def set_angles(self, azimuth=None, elevation=None):
        """Sets Azimuth and/or Elevation setpoints (4-byte floats)."""
        if elevation is not None:
            self._send_command(0x20, struct.pack('<f', float(elevation)))
        if azimuth is not None:
            self._send_command(0x21, struct.pack('<f', float(azimuth)))

    def set_orientation(self, pitch=None, yaw=None, roll=None):
        """Sets Pitch, Yaw, or Roll setpoints."""
        if pitch is not None: self._send_command(0x22, struct.pack('<f', float(pitch)))
        if yaw is not None:   self._send_command(0x23, struct.pack('<f', float(yaw)))
        if roll is not None:  self._send_command(0x24, struct.pack('<f', float(roll)))

    def control_actuator(self, command_type="engage", state=0x00):
        """
        command_type: "engage" (0x25) or "extend" (0x29)
        state: 0x00 (Retract), 0xFF (Extend/Engage)
        """
        msg_type = 0x25 if command_type == "engage" else 0x29
        self._send_command(msg_type, bytes([state]))

    def control_brake(self, action="apply"):
        """action: "apply" (0x27) or "release" (0x28)"""
        if action == "apply":
            self._send_command(0x27, bytes([0x01])) # Sending 1 byte payload as per struct
        else:
            self._send_command(0x28, bytes([0x01]))

    def get_status(self):
        with self.lock:
            return self.state.copy()

# --- Main Application Logic ---
if __name__ == "__main__":
    gimbal = Gimbal(port='/dev/ttyUSB0') # Adjust to your port (e.g., 'COM3')
    
    if gimbal.start():
        try:
            while PROGRAM_STATUS:
                # 1. Read latest status
                status = gimbal.get_status()
                print(f"\r[STATUS] AZ: {status['azimuth']:.2f} EL: {status['elevation']:.2f} "
                      f"Act: {status['actuator']} Brake: {status['brake']}", end="")

                # 2. Example: Send Commands based on logic
                # Let's say we want to move to 45, 45 if we aren't there
                # gimbal.set_angles(azimuth=45.0, elevation=45.0)
                
                # gimbal.control_brake("release")
                # gimbal.control_actuator("extend", 0xFF)

                time.sleep(0.1) # Main loop rate

        except KeyboardInterrupt:
            print("\n[Main] User interrupted. Shutting down...")
            PROGRAM_STATUS = False
            time.sleep(0.5)


"""
Azimuth and Elevation Status Command Packet Structure: (12 bytes)
Header  Message_Length  Message_Type    Azimuth     Elevation  Checksum
(0xAA)      (0x0C)        (0x0A)        (4 bytes)   (4 bytes)  (dependant on data)

Actuator Engage Status Command Packet Structure: (5 bytes)
Header  Message_Length  Message_Type    Actuator      Checksum
(0xAA)      (0x05)        (0x25)        (1 bytes)    (dependant on data)
0x00 - Retracted
0xFF - Extended
0x55 - in Motion

Brake Engage Status Command Packet Structure: (5 bytes)
Header  Message_Length  Message_Type    Brake        Checksum
(0xAA)      (0x05)        (0x27)        (0x0B)    (dependant on data)

Brake Disengage Status Command Packet Structure: (5 bytes)
Header  Message_Length  Message_Type    Brake        Checksum
(0xAA)      (0x05)        (0x28)        (0x0C)    (dependant on data)

Actuator Extend Status Command Packet Structure: (5 bytes)
Header  Message_Length  Message_Type    Actuator      Checksum
(0xAA)      (0x05)        (0x29)        (1 bytes)    (dependant on data)
0x00 - Retracted
0xFF - Extended
0x65 - in Motion
"""


"""
Elevation Setpoint Command Packet Structure: (8 bytes)
Header  Message_Length  Message_Type    Elevation  Checksum
(0xAA)      (0x08)        (0x20)        (4 bytes)  (dependant on data)

Azimuth Setpoint Command Packet Structure: (8 bytes)
Header  Message_Length  Message_Type    Azimuth      Checksum
(0xAA)      (0x08)        (0x21)        (4 bytes)    (dependant on data)

Pitch Setpoint Command Packet Structure: (8 bytes)
Header  Message_Length  Message_Type    Pitch        Checksum
(0xAA)      (0x08)        (0x22)        (4 bytes)    (dependant on data)

Yaw Setpoint Command Packet Structure: (8 bytes)
Header  Message_Length  Message_Type    Yaw          Checksum
(0xAA)      (0x08)        (0x23)        (4 bytes)    (dependant on data)

Roll Setpoint Command Packet Structure: (8 bytes)
Header  Message_Length  Message_Type    Roll         Checksum
(0xAA)      (0x08)        (0x24)        (4 bytes)    (dependant on data)

Engage Actuator Command Packet Structure: (5 bytes)
Header  Message_Length  Message_Type    Actuator      Checksum
(0xAA)      (0x05)        (0x25)        (1 bytes)    (dependant on data)

Apply Brake Command Packet Structure: (5 bytes)
Header  Message_Length  Message_Type    Brake        Checksum
(0xAA)      (0x05)        (0x27)        (1 bytes)    (dependant on data)

Release Brake Command Packet Structure: (5 bytes)
Header  Message_Length  Message_Type    Brake        Checksum
(0xAA)      (0x05)        (0x28)        (1 bytes)    (dependant on data)

Extend Actuator Command Packet Structure: (5 bytes)
Header  Message_Length  Message_Type    Actuator      Checksum
(0xAA)      (0x05)        (0x29)        (1 bytes)    (dependant on data)
"""

""

#   https://pdm.fming.dev/#use-with-ide
.pdm.toml

# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# pytype static type analyzer
.pytype/

# Cython debug symbols
cython_debug/

# PyCharm
#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can
#  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
#  and can be added to the global gitignore or merged into this file.  For a more nuclear
#  option (not recommended) you can uncomment the following to ignore the entire idea folder.
#.idea/
